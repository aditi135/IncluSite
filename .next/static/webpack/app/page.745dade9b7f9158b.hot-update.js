"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/queries.js":
/*!************************!*\
  !*** ./app/queries.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterData: function() { return /* binding */ filterData; },\n/* harmony export */   getScore: function() { return /* binding */ getScore; }\n/* harmony export */ });\n(__webpack_require__(/*! dotenv */ \"(app-pages-browser)/./node_modules/dotenv/lib/main.js\").config)();\n// const {MongoClient} = require(\"mongodb\");\n// async function findDataByURL(client, URL) {\n//     const data = await client.db(process.env.DB_NAME).collection(process.env.COLLECTION_NAME_AXE_UPDATED)\n//                              .findOne({url : URL});\n//     return data;\n// }\n// async function searchData(client, string) {\n//     var data = await client.db(process.env.DB_NAME).collection(process.env.COLLECTION_NAME_AXE_UPDATED)\n//                              .find({url : {$regex: string}});\n//     data = await data.toArray();\n//     data.sort(function(a, b) {\n//         a_score = a.pass_count / (a.pass_count + a.incomplete_count + a.violation_count); // DECISION: prioritize GENERAL or FILTERED accessibility? maybe let them pick?\n//         b_score = b.pass_count / (b.pass_count + b.incomplete_count + b.violation_count);\n//         return b_score - a_score;\n//     });\n//     return data;\n// }\nfunction filterData(search_results) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    search_results.sort(function(a, b) {\n        let a_score = 0;\n        let b_score = 0;\n        if (filters.length == 0) {\n            a_score = a.pass_count / (a.pass_count + a.incomplete_count + a.violation_count);\n            b_score = b.pass_count / (b.pass_count + b.incomplete_count + b.violation_count);\n        }\n        for(var i = 0; i < filters.length; i++){\n            try {\n                if (a[filters[i]] == \"pass\") {\n                    a_score += 1 / (a.pass_count + a.incomplete_count + a.violation_count);\n                } else if (a[filters[i]] == \"violation\") {\n                    a_score -= 1 / (a.pass_count + a.incomplete_count + a.violation_count);\n                }\n            } catch (e) {}\n            try {\n                if (b[filters[i]] == \"pass\") {\n                    b_score += 1 / (b.pass_count + b.incomplete_count + b.violation_count);\n                } else if (b[filters[i]] == \"violation\") {\n                    b_score -= 1 / (b.pass_count + b.incomplete_count + b.violation_count);\n                }\n            } catch (e) {}\n        }\n        return b_score - a_score;\n    });\n    return search_results;\n}\nfunction getScore(data) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    let score = 0;\n    if (filters.length == 0) {\n        score = data.pass_count / (data.pass_count + data.incomplete_count + data.violation_count);\n    }\n    for(var i = 0; i < filters.length; i++){\n        try {\n            if (data[filters[i]] == \"pass\") {\n                score += 1 / (data.pass_count + data.incomplete_count + data.violation_count);\n            }\n        } catch (e) {}\n    }\n    return score;\n} // async function connectToDb(query, filters=[]) {\n //     console.log(query);\n //     console.log(filters);\n //     const client = new MongoClient(process.env.MONGO_DB_URI);\n //     try {\n //         await client.connect();\n //         var query_data = await searchData(client, query);\n //         query_data = await filterData(query_data, filters);\n //     } catch (e) {\n //         console.error(e);\n //     } finally {\n //         await client.close();\n //     }\n //     return query_data;\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WTtDQUNaLGtDQUFrQztDQUVsQyw0REFBNEQ7Q0FDNUQsOERBQThEO0NBQzlELG9CQUFvQjtDQUNwQiw0QkFBNEI7Q0FDNUIsa0JBQWtCO0NBQ2xCLGdDQUFnQztDQUNoQyxRQUFRO0NBQ1IseUJBQXlCO0NBQ3pCLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3F1ZXJpZXMuanM/NTZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiZG90ZW52XCIpLmNvbmZpZygpO1xuLy8gY29uc3Qge01vbmdvQ2xpZW50fSA9IHJlcXVpcmUoXCJtb25nb2RiXCIpO1xuXG4vLyBhc3luYyBmdW5jdGlvbiBmaW5kRGF0YUJ5VVJMKGNsaWVudCwgVVJMKSB7XG4vLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5kYihwcm9jZXNzLmVudi5EQl9OQU1FKS5jb2xsZWN0aW9uKHByb2Nlc3MuZW52LkNPTExFQ1RJT05fTkFNRV9BWEVfVVBEQVRFRClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmRPbmUoe3VybCA6IFVSTH0pO1xuLy8gICAgIHJldHVybiBkYXRhO1xuLy8gfVxuXG4vLyBhc3luYyBmdW5jdGlvbiBzZWFyY2hEYXRhKGNsaWVudCwgc3RyaW5nKSB7XG4vLyAgICAgdmFyIGRhdGEgPSBhd2FpdCBjbGllbnQuZGIocHJvY2Vzcy5lbnYuREJfTkFNRSkuY29sbGVjdGlvbihwcm9jZXNzLmVudi5DT0xMRUNUSU9OX05BTUVfQVhFX1VQREFURUQpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHt1cmwgOiB7JHJlZ2V4OiBzdHJpbmd9fSk7XG4vLyAgICAgZGF0YSA9IGF3YWl0IGRhdGEudG9BcnJheSgpO1xuLy8gICAgIGRhdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG4vLyAgICAgICAgIGFfc2NvcmUgPSBhLnBhc3NfY291bnQgLyAoYS5wYXNzX2NvdW50ICsgYS5pbmNvbXBsZXRlX2NvdW50ICsgYS52aW9sYXRpb25fY291bnQpOyAvLyBERUNJU0lPTjogcHJpb3JpdGl6ZSBHRU5FUkFMIG9yIEZJTFRFUkVEIGFjY2Vzc2liaWxpdHk/IG1heWJlIGxldCB0aGVtIHBpY2s/XG4vLyAgICAgICAgIGJfc2NvcmUgPSBiLnBhc3NfY291bnQgLyAoYi5wYXNzX2NvdW50ICsgYi5pbmNvbXBsZXRlX2NvdW50ICsgYi52aW9sYXRpb25fY291bnQpO1xuLy8gICAgICAgICByZXR1cm4gYl9zY29yZSAtIGFfc2NvcmU7XG4vLyAgICAgfSk7XG4vLyAgICAgcmV0dXJuIGRhdGE7XG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJEYXRhKHNlYXJjaF9yZXN1bHRzLCBmaWx0ZXJzID0gW10pIHtcbiAgc2VhcmNoX3Jlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIGxldCBhX3Njb3JlID0gMDtcbiAgICBsZXQgYl9zY29yZSA9IDA7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09IDApIHtcbiAgICAgIGFfc2NvcmUgPVxuICAgICAgICBhLnBhc3NfY291bnQgLyAoYS5wYXNzX2NvdW50ICsgYS5pbmNvbXBsZXRlX2NvdW50ICsgYS52aW9sYXRpb25fY291bnQpO1xuICAgICAgYl9zY29yZSA9XG4gICAgICAgIGIucGFzc19jb3VudCAvIChiLnBhc3NfY291bnQgKyBiLmluY29tcGxldGVfY291bnQgKyBiLnZpb2xhdGlvbl9jb3VudCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGFbZmlsdGVyc1tpXV0gPT0gXCJwYXNzXCIpIHtcbiAgICAgICAgICBhX3Njb3JlICs9XG4gICAgICAgICAgICAxIC8gKGEucGFzc19jb3VudCArIGEuaW5jb21wbGV0ZV9jb3VudCArIGEudmlvbGF0aW9uX2NvdW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChhW2ZpbHRlcnNbaV1dID09IFwidmlvbGF0aW9uXCIpIHtcbiAgICAgICAgICBhX3Njb3JlIC09XG4gICAgICAgICAgICAxIC8gKGEucGFzc19jb3VudCArIGEuaW5jb21wbGV0ZV9jb3VudCArIGEudmlvbGF0aW9uX2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGJbZmlsdGVyc1tpXV0gPT0gXCJwYXNzXCIpIHtcbiAgICAgICAgICBiX3Njb3JlICs9XG4gICAgICAgICAgICAxIC8gKGIucGFzc19jb3VudCArIGIuaW5jb21wbGV0ZV9jb3VudCArIGIudmlvbGF0aW9uX2NvdW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChiW2ZpbHRlcnNbaV1dID09IFwidmlvbGF0aW9uXCIpIHtcbiAgICAgICAgICBiX3Njb3JlIC09XG4gICAgICAgICAgICAxIC8gKGIucGFzc19jb3VudCArIGIuaW5jb21wbGV0ZV9jb3VudCArIGIudmlvbGF0aW9uX2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICByZXR1cm4gYl9zY29yZSAtIGFfc2NvcmU7XG4gIH0pO1xuICByZXR1cm4gc2VhcmNoX3Jlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY29yZShkYXRhLCBmaWx0ZXJzID0gW10pIHtcbiAgbGV0IHNjb3JlID0gMDtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09IDApIHtcbiAgICBzY29yZSA9XG4gICAgZGF0YS5wYXNzX2NvdW50IC8gKGRhdGEucGFzc19jb3VudCArIGRhdGEuaW5jb21wbGV0ZV9jb3VudCArIGRhdGEudmlvbGF0aW9uX2NvdW50KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGRhdGFbZmlsdGVyc1tpXV0gPT0gXCJwYXNzXCIpIHtcbiAgICAgICAgc2NvcmUgKz0gMSAvIChkYXRhLnBhc3NfY291bnQgKyBkYXRhLmluY29tcGxldGVfY291bnQgKyBkYXRhLnZpb2xhdGlvbl9jb3VudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7fVxuICB9XG4gIHJldHVybiBzY29yZTtcbn1cblxuLy8gYXN5bmMgZnVuY3Rpb24gY29ubmVjdFRvRGIocXVlcnksIGZpbHRlcnM9W10pIHtcbi8vICAgICBjb25zb2xlLmxvZyhxdWVyeSk7XG4vLyAgICAgY29uc29sZS5sb2coZmlsdGVycyk7XG4vLyAgICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHByb2Nlc3MuZW52Lk1PTkdPX0RCX1VSSSk7XG4vLyAgICAgdHJ5IHtcbi8vICAgICAgICAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcblxuLy8gICAgICAgICB2YXIgcXVlcnlfZGF0YSA9IGF3YWl0IHNlYXJjaERhdGEoY2xpZW50LCBxdWVyeSk7XG4vLyAgICAgICAgIHF1ZXJ5X2RhdGEgPSBhd2FpdCBmaWx0ZXJEYXRhKHF1ZXJ5X2RhdGEsIGZpbHRlcnMpO1xuLy8gICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbi8vICAgICB9IGZpbmFsbHkge1xuLy8gICAgICAgICBhd2FpdCBjbGllbnQuY2xvc2UoKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHF1ZXJ5X2RhdGE7XG4vLyB9XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNvbmZpZyIsImZpbHRlckRhdGEiLCJzZWFyY2hfcmVzdWx0cyIsImZpbHRlcnMiLCJzb3J0IiwiYSIsImIiLCJhX3Njb3JlIiwiYl9zY29yZSIsImxlbmd0aCIsInBhc3NfY291bnQiLCJpbmNvbXBsZXRlX2NvdW50IiwidmlvbGF0aW9uX2NvdW50IiwiaSIsImdldFNjb3JlIiwiZGF0YSIsInNjb3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/queries.js\n"));

/***/ })

});