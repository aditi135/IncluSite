"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/queries.js":
/*!************************!*\
  !*** ./app/queries.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterData: function() { return /* binding */ filterData; },\n/* harmony export */   getScore: function() { return /* binding */ getScore; }\n/* harmony export */ });\n(__webpack_require__(/*! dotenv */ \"(app-pages-browser)/./node_modules/dotenv/lib/main.js\").config)();\n// const {MongoClient} = require(\"mongodb\");\n// async function findDataByURL(client, URL) {\n//     const data = await client.db(process.env.DB_NAME).collection(process.env.COLLECTION_NAME_AXE_UPDATED)\n//                              .findOne({url : URL});\n//     return data;\n// }\n// async function searchData(client, string) {\n//     var data = await client.db(process.env.DB_NAME).collection(process.env.COLLECTION_NAME_AXE_UPDATED)\n//                              .find({url : {$regex: string}});\n//     data = await data.toArray();\n//     data.sort(function(a, b) {\n//         a_score = a.pass_count / (a.pass_count + a.incomplete_count + a.violation_count); // DECISION: prioritize GENERAL or FILTERED accessibility? maybe let them pick?\n//         b_score = b.pass_count / (b.pass_count + b.incomplete_count + b.violation_count);\n//         return b_score - a_score;\n//     });\n//     return data;\n// }\nfunction filterData(search_results) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    search_results.sort(function(a, b) {\n        let a_score = 0;\n        let b_score = 0;\n        if (filters.length == 0) {\n            a_score = a.pass_count / (a.pass_count + a.incomplete_count + a.violation_count);\n            b_score = b.pass_count / (b.pass_count + b.incomplete_count + b.violation_count);\n        }\n        for(var i = 0; i < filters.length; i++){\n            try {\n                if (a[filters[i]] == \"pass\") {\n                    a_score += 1 / (a.pass_count + a.incomplete_count + a.violation_count);\n                } else if (a[filters[i]] == \"violation\") {\n                    a_score -= 1 / (a.pass_count + a.incomplete_count + a.violation_count);\n                }\n            } catch (e) {}\n            try {\n                if (b[filters[i]] == \"pass\") {\n                    b_score += 1 / (b.pass_count + b.incomplete_count + b.violation_count);\n                } else if (b[filters[i]] == \"violation\") {\n                    b_score -= 1 / (b.pass_count + b.incomplete_count + b.violation_count);\n                }\n            } catch (e) {}\n        }\n        return b_score - a_score;\n    });\n    return search_results;\n}\nfunction getScore(data) {\n    let filters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    let score = 0;\n    if (filters.length == 0) {\n        score = data.pass_count / (data.pass_count + data.incomplete_count + data.violation_count);\n        return score;\n    }\n    let count = 0;\n    for(var i = 0; i < filters.length; i++){\n        try {\n            if (data[filters[i]] == \"pass\") {\n                score += 1; // (filters.length);\n            }\n            count += 1;\n        } catch (e) {}\n    }\n    if (count == 0) {\n        count += 1;\n    }\n    score = score / count;\n    return score;\n} // async function connectToDb(query, filters=[]) {\n //     console.log(query);\n //     console.log(filters);\n //     const client = new MongoClient(process.env.MONGO_DB_URI);\n //     try {\n //         await client.connect();\n //         var query_data = await searchData(client, query);\n //         query_data = await filterData(query_data, filters);\n //     } catch (e) {\n //         console.error(e);\n //     } finally {\n //         await client.close();\n //     }\n //     return query_data;\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNsRCwwQkFBMEI7Q0FDMUIsNEJBQTRCO0NBQzVCLGdFQUFnRTtDQUNoRSxZQUFZO0NBQ1osa0NBQWtDO0NBRWxDLDREQUE0RDtDQUM1RCw4REFBOEQ7Q0FDOUQsb0JBQW9CO0NBQ3BCLDRCQUE0QjtDQUM1QixrQkFBa0I7Q0FDbEIsZ0NBQWdDO0NBQ2hDLFFBQVE7Q0FDUix5QkFBeUI7Q0FDekIsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcXVlcmllcy5qcz81NmZlIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCJkb3RlbnZcIikuY29uZmlnKCk7XG4vLyBjb25zdCB7TW9uZ29DbGllbnR9ID0gcmVxdWlyZShcIm1vbmdvZGJcIik7XG5cbi8vIGFzeW5jIGZ1bmN0aW9uIGZpbmREYXRhQnlVUkwoY2xpZW50LCBVUkwpIHtcbi8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LmRiKHByb2Nlc3MuZW52LkRCX05BTUUpLmNvbGxlY3Rpb24ocHJvY2Vzcy5lbnYuQ09MTEVDVElPTl9OQU1FX0FYRV9VUERBVEVEKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZE9uZSh7dXJsIDogVVJMfSk7XG4vLyAgICAgcmV0dXJuIGRhdGE7XG4vLyB9XG5cbi8vIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaERhdGEoY2xpZW50LCBzdHJpbmcpIHtcbi8vICAgICB2YXIgZGF0YSA9IGF3YWl0IGNsaWVudC5kYihwcm9jZXNzLmVudi5EQl9OQU1FKS5jb2xsZWN0aW9uKHByb2Nlc3MuZW52LkNPTExFQ1RJT05fTkFNRV9BWEVfVVBEQVRFRClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoe3VybCA6IHskcmVnZXg6IHN0cmluZ319KTtcbi8vICAgICBkYXRhID0gYXdhaXQgZGF0YS50b0FycmF5KCk7XG4vLyAgICAgZGF0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbi8vICAgICAgICAgYV9zY29yZSA9IGEucGFzc19jb3VudCAvIChhLnBhc3NfY291bnQgKyBhLmluY29tcGxldGVfY291bnQgKyBhLnZpb2xhdGlvbl9jb3VudCk7IC8vIERFQ0lTSU9OOiBwcmlvcml0aXplIEdFTkVSQUwgb3IgRklMVEVSRUQgYWNjZXNzaWJpbGl0eT8gbWF5YmUgbGV0IHRoZW0gcGljaz9cbi8vICAgICAgICAgYl9zY29yZSA9IGIucGFzc19jb3VudCAvIChiLnBhc3NfY291bnQgKyBiLmluY29tcGxldGVfY291bnQgKyBiLnZpb2xhdGlvbl9jb3VudCk7XG4vLyAgICAgICAgIHJldHVybiBiX3Njb3JlIC0gYV9zY29yZTtcbi8vICAgICB9KTtcbi8vICAgICByZXR1cm4gZGF0YTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRhdGEoc2VhcmNoX3Jlc3VsdHMsIGZpbHRlcnMgPSBbXSkge1xuICBzZWFyY2hfcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbGV0IGFfc2NvcmUgPSAwO1xuICAgIGxldCBiX3Njb3JlID0gMDtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT0gMCkge1xuICAgICAgYV9zY29yZSA9XG4gICAgICAgIGEucGFzc19jb3VudCAvIChhLnBhc3NfY291bnQgKyBhLmluY29tcGxldGVfY291bnQgKyBhLnZpb2xhdGlvbl9jb3VudCk7XG4gICAgICBiX3Njb3JlID1cbiAgICAgICAgYi5wYXNzX2NvdW50IC8gKGIucGFzc19jb3VudCArIGIuaW5jb21wbGV0ZV9jb3VudCArIGIudmlvbGF0aW9uX2NvdW50KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYVtmaWx0ZXJzW2ldXSA9PSBcInBhc3NcIikge1xuICAgICAgICAgIGFfc2NvcmUgKz1cbiAgICAgICAgICAgIDEgLyAoYS5wYXNzX2NvdW50ICsgYS5pbmNvbXBsZXRlX2NvdW50ICsgYS52aW9sYXRpb25fY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGFbZmlsdGVyc1tpXV0gPT0gXCJ2aW9sYXRpb25cIikge1xuICAgICAgICAgIGFfc2NvcmUgLT1cbiAgICAgICAgICAgIDEgLyAoYS5wYXNzX2NvdW50ICsgYS5pbmNvbXBsZXRlX2NvdW50ICsgYS52aW9sYXRpb25fY291bnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYltmaWx0ZXJzW2ldXSA9PSBcInBhc3NcIikge1xuICAgICAgICAgIGJfc2NvcmUgKz1cbiAgICAgICAgICAgIDEgLyAoYi5wYXNzX2NvdW50ICsgYi5pbmNvbXBsZXRlX2NvdW50ICsgYi52aW9sYXRpb25fY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGJbZmlsdGVyc1tpXV0gPT0gXCJ2aW9sYXRpb25cIikge1xuICAgICAgICAgIGJfc2NvcmUgLT1cbiAgICAgICAgICAgIDEgLyAoYi5wYXNzX2NvdW50ICsgYi5pbmNvbXBsZXRlX2NvdW50ICsgYi52aW9sYXRpb25fY291bnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiBiX3Njb3JlIC0gYV9zY29yZTtcbiAgfSk7XG4gIHJldHVybiBzZWFyY2hfcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjb3JlKGRhdGEsIGZpbHRlcnMgPSBbXSkge1xuICBsZXQgc2NvcmUgPSAwO1xuICBpZiAoZmlsdGVycy5sZW5ndGggPT0gMCkge1xuICAgIHNjb3JlID1cbiAgICBkYXRhLnBhc3NfY291bnQgLyAoZGF0YS5wYXNzX2NvdW50ICsgZGF0YS5pbmNvbXBsZXRlX2NvdW50ICsgZGF0YS52aW9sYXRpb25fY291bnQpO1xuICAgIHJldHVybiBzY29yZTtcbiAgfVxuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGRhdGFbZmlsdGVyc1tpXV0gPT0gXCJwYXNzXCIpIHtcbiAgICAgICAgc2NvcmUgKz0gMTsvLyAoZmlsdGVycy5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY291bnQgKz0gMTtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgaWYgKGNvdW50ID09IDApIHtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHNjb3JlID0gc2NvcmUgLyBjb3VudDtcbiAgcmV0dXJuIHNjb3JlO1xufVxuXG4vLyBhc3luYyBmdW5jdGlvbiBjb25uZWN0VG9EYihxdWVyeSwgZmlsdGVycz1bXSkge1xuLy8gICAgIGNvbnNvbGUubG9nKHF1ZXJ5KTtcbi8vICAgICBjb25zb2xlLmxvZyhmaWx0ZXJzKTtcbi8vICAgICBjb25zdCBjbGllbnQgPSBuZXcgTW9uZ29DbGllbnQocHJvY2Vzcy5lbnYuTU9OR09fREJfVVJJKTtcbi8vICAgICB0cnkge1xuLy8gICAgICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuXG4vLyAgICAgICAgIHZhciBxdWVyeV9kYXRhID0gYXdhaXQgc2VhcmNoRGF0YShjbGllbnQsIHF1ZXJ5KTtcbi8vICAgICAgICAgcXVlcnlfZGF0YSA9IGF3YWl0IGZpbHRlckRhdGEocXVlcnlfZGF0YSwgZmlsdGVycyk7XG4vLyAgICAgfSBjYXRjaCAoZSkge1xuLy8gICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuLy8gICAgIH0gZmluYWxseSB7XG4vLyAgICAgICAgIGF3YWl0IGNsaWVudC5jbG9zZSgpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gcXVlcnlfZGF0YTtcbi8vIH1cbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY29uZmlnIiwiZmlsdGVyRGF0YSIsInNlYXJjaF9yZXN1bHRzIiwiZmlsdGVycyIsInNvcnQiLCJhIiwiYiIsImFfc2NvcmUiLCJiX3Njb3JlIiwibGVuZ3RoIiwicGFzc19jb3VudCIsImluY29tcGxldGVfY291bnQiLCJ2aW9sYXRpb25fY291bnQiLCJpIiwiZ2V0U2NvcmUiLCJkYXRhIiwic2NvcmUiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/queries.js\n"));

/***/ })

});